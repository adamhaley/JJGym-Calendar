<?
/** 
*The "Model" in Model-View-Controller. 
*
*This is an abstract superclass that represents the behavior of all "resources". 
*It Implements Active Record pattern.
*Class resource should be subclassed with one class to represent each table in the db.
*The subsequent subclasses will define their datastructures in the constructor. 
*Each instance of those classes will represent a row in its respective db table.
*@link http://www.martinfowler.com/eaaCatalog/activeRecord.html
*@link http://www.martinfowler.com/eaaCatalog/modelViewController.html
*
*@author Adam Haley <adam.haley@disney.com>
*@access public
*@category ModelViewController
*
*/
abstract class resource{
	/**
	*@var bool The "new" flag. this gets set to "0" when a resource is loaded from the db 
	*/
	var $new = 1;
	/**
	*@var string The "table" var. this holds the db tablename that the specific resource subclass represents.
	*This var only needs to be set when the classname differs from the tablename.
	*/
	var $table;

	
	abstract function __construct();
	
	/**
	*Returns associative array of property/values
	*If you pass an array of property names, it will return an associative array containing only those properties in the array
	*@param array $array filter array .. send an array of only the props you want to return and voila
	*@return array associative array of properties/values
	*/
	function get_props_array($array=array()){
	
		$ret = array();
		if(count($array)){
			foreach($array as $prop){
				if($prop==$this->get_id_string()){
					$ret['id'] = $this->get_prop($prop);
				}
				$ret[$prop] = $this->get_prop($prop);	
			}	
		}else{
			foreach($this->props as $k => $v){

				$ret[$k] = $this->get_prop($k);	
			}	
		}	
		return $ret;
	}
	
	
	/**
	*Adds a key/value pair to the magical data-defining resource::props array.
	*It will then be automatically added to the metadata definition in the xml.
	*$attribute is the key, $value is the value
	*@param string $prop
	*@param string $attribute
	*@param string $value
	*/
	function set_prop_attribute($prop,$attribute,$value){
		$this->props[$prop][$attribute] = $value;
	}

	/**
	*Returns true or false whether a given property name exists or not	
	*@param string $propname
	*@return int 1 or 0
	*/
	function prop_exists($propname){
		return array_key_exists($propname,$this->props);
	}
	/**
	*Returns the name of the id field in the db according to the naming convention "id_[tablename]"
	*@return string name of id field - follows id_[tablename] convention
	*/
	function get_id_string(){
		return 'id_' . $this->get_table();
	}

	/**
	*Returns the string name of the Database Table the resource saves to.
	*This should be the same as the classname,but can be overridden with the $table instance var
	*
	*@return string table name
	*/
	function get_table(){
		return $this->table ? $this->table : get_class($this);
	}

	/**
	*Returns prop/values as xml
	*Include property metadata as attributes
	*@return string xml
	*/
	function get_props_xml_use_attributes(){
		$class = $this->class? $this->class : get_class($this);
		$out = "";
		$array = $this->get_props_array();
		foreach($array as $k => $v){
	
			$view = $this->props[$k]['view'];
			
			$v = $this->_replace_special_chars($v);
			
			$varray = str_split($view);
			$view = $varray[0];
			
			$out .= "\t<$k ";
			foreach($this->props[$k] as $key => $value){
				if($key== 'view'){
					$value = $view;	
				}
				if($key != 'value' && $key != 'object' &&$key != 'map'){
					$value = $this->_replace_special_chars($value);
					
					
					if($key == 'list' && is_array($value)){
							$array = $value;
							$value = '';
							foreach($array as $l){
								$value .= $l . ",";
							}
							$value = preg_replace("/,$/","",$value);
					}
					$out .= " $key='$value' ";	
				}
			}
		
			$out .= ">$v</$k>\n";	
		}
		return $out;
	}

	/**
        *Returns prop/values as xml
        *Used by {@link view::build_xml()}
	*@return string xml
	*/
        function get_meta_xml(){
                $class = $this->class? $this->class : get_class($this);
                $out = "";
                $array = $this->get_props_array();
                foreach($array as $k => $v){

                        $view = $this->props[$k]['view'];

                        $v = $this->_replace_special_chars($v);


                        $out .= "\t<$k>\n";

                        foreach($this->props[$k] as $key => $value){

                                if($key != 'value' && $key != 'object' && $key != 'map'){
                                        $value = $this->_replace_special_chars($value);

                                        $out .= "\t\t<$key>";
                                        if($key == 'list' && is_array($value)){
                                                        $out .= "\n\t\t";
                                                        $array = $value;
                                                        $value = '';
                                                        foreach($array as $listkey => $listvalue){
                                                                $out .= "\t<choice>\n";
                                                                $out .= "\t\t\t\t<key>$listkey</key>\n";
                                                                $out .= "\t\t\t\t<value>$listvalue</value>\n";
                                                                $out .= "\t\t\t</choice>\n\t\t";
                                                        }
                                        }else{
                                                $out .= $value;
                                        }
                                        $out .= "</$key>\n";
                                }
                        }
                        $out .= "\t</$k>\n";
                }
                return $out;
        }

	/**
        *Returns prop/values as xml
	*Used by {@link resource::get_resource_xml()}
	*
        *@return string xml
	*/
        function get_props_xml(){
                $class = $this->class? $this->class : get_class($this);
                $out = "";
                $array = $this->get_props_array();
                foreach($array as $k => $v){

                        $view = $this->props[$k]['view'];

                        $v = $this->_replace_special_chars($v);

                        $out .= "\t<$k>";
			$out .= $v;
                        $out .= "</$k>\n";
                }
                return $out;
        }

	/**
	*Gets entire resource as xml
	*Uses {@link resource::get_props_xml()}. 
	*Used by {@link view::build_xml()}
	*@return string xml
	*/
	function get_resource_xml(){
		$out = "<resource class=\"" . get_class($this) . "\">\n";
		$out .= $this->get_props_xml();	
		$out .= "</resource>\n";
		return $out;
	}

	/**
	*replace illegal xml characters and return 
	*@param string $v this is an internally used function for replacing special characters in xml
	*replaces left-carrots, right-carrots, apostrophies and amperstands with their HTML entities
	*/

	function _replace_special_chars($v){
		$v = str_replace("&","&amp;",$v);
		$v = str_replace("<","&lt;",$v);
		$v = str_replace(">","&gt;",$v);	
		$v = str_replace("'","&#39;",$v);
		return $v;
	}
	
	/**
	*Gets all resources where conditions match. return as xml
	*@param array $conditions conditions filter array formatted according to {@link sql_generator::where_clause()}
	*/
	function get_all_xml($conditions=array()){
		$objarray = $this->get_all($conditions);
		foreach($objarray as $obj){
			$out .= $obj->get_props_xml();	
		}
		return $out;
	}
	
	/**
	*Does some string manipulation to the classname to return a Human-Friendly version.
	*Basically, gets the classname,then replaces underscores with spaces and capitalises words.
	*No need to pass any params, this function gets the classname itself.
	*@return string friendly classname of the current resource. 
	*
	*/
	function friendly_classname(){
		$class = get_class($this);
		$class = str_replace("_"," ",$class);
		return ucwords($class);	
	}
	
	/**
	*Takes an id and loads the resource with data from the record in question
	*@param int $id
	*/
	function load($id){
		
		global $message;
		global $dbcache;
		
		
		//if no id, nothing for this function to do so get outta here.
		if(!$id){
			
			return false;
		}
		
		$sqlgen = new sql_generator($this);
		$sql = $sqlgen->select();
		//set the id property to the id passed
		$this->set_prop('id',$id);
		
		if($sql){

			//get the id field
			$idfield = $this->get_table() . "." . $this->get_id_string();
			
			//add id condition to where clause  -- very important ;)
			$sql .= " and $idfield=" . $id;
		
			//run query
			$res = $dbcache->query($sql);
			
			//get row
			$row = $res->fetchrow();
		}else{
			//if no sql, gimmie an error
			$message->add("error","empty sql");	
		}
		
		if(!is_array($row)){
			$message->add("warning",$this->friendly_classname() . " " .  $id . " Not Found.");
			return false;	
		}	
		//loop through, set property values
		foreach($row as $k => $v){
			$v = stripslashes($v);	
			if($this->props[$k]['datatype'] == 'date'){
					$v = $this->format_datetime($v);
				}
				if(!$this->prop_exists($k)){
					$this->add_prop($k,$v);
				}else{

					$value = $this->get_prop($k);
				/*
				if(!$this->prop_exists($k)){
					$this->add_prop($k);
				}
				*/
					if($value == '' || $value == '1' || $value == '0'){
			
						$this->set_prop($k,$v);//set prop to value
					}
				}
		}
		//set new to false
		$this->new = 0;
		return;
	}
	
	/**
	*
        *finds and returns a resource of this class where $conditions
        *otherwise returns nothing
	*
	*@param array $conditions - format according to {@link sql_generator::where_clause()}
	*@return resource resource of this class or nada if it didn't find one.
	*
	*/
	function find($conditions = array()){
		$array = array();
		$array = $this->get_all($conditions);
		if(count($array)){
			return $array[0];
		}
	}


	/**
	*Returns an array of all  resources of this class - in other words - all records in this db table in resource object form
        *Filters using the $conditions array - see {@link sql_generator::where_clause()} for more info on how to format this array.
	*@param array $conditions
	*@return array resource array
	*/
	
	function get_all($conditions = array()){
		global $dbcache;
		global $message;


		//gets the sql filename for a select
		$sqlgen = new sql_generator($this);
		$sql = $sqlgen->get_sql('select');

		if($sql){
			$cond = $this->sql_conditions($conditions);
		
			$sql .= $cond;

			$res = $dbcache->query($sql);
		
			$classname = get_class($this);
			$array = array();
			
			//loop through query results
			//create new object for each row & return array
			$rows = $res->fetchallrows();
			foreach($rows as $row){
					eval("\$obj = new $classname;");
					$obj->new = 0;
					foreach($row as $k => $v){	
						if($this->props[$k]['datatype'] == 'date'){
                                        		$v = $this->format_datetime($v);
                                		}
						//echo " $k :: $v <br />\n";
						$obj->set_prop($k,$v);
					}	
				$array[] = $obj;
			}
			return $array;
		}else{
			$message->add("error","empty sql from $sqlfile");	
		}
	}
	
	/**
	*Clears all the properties, sets their value to ''
	*/
	function clear(){
		//the opposite of populate, this function clears all the properties of a resource
		foreach($this->props as $k => $v){
			$this->props[$k]['value'] = '';	
		}
	}
		
	/**
	*Sets the given property name to the given value
	*@param $prop
	*@param $value
	*/ 
	function set_prop($prop,$value){
		//set property
		if($prop == 'id'){
			$this->props[$this->get_id_string()]['value'] = $value;
			$this->add_prop('id');
		}
		if($prop  == $this->get_id_string()){
			$this->props['id']['value'] = $value;
		}

		if(isset($this->props[$prop])){
		
			$this->props[$prop]['value'] = $value;
		}
	}
	
	/**
	*Takes a property name and returns the value
	*@param string $prop
	*@return string 
	*/ 
  	function get_prop($prop){
    		global $message;
    		//get property
    		$value = $this->props[$prop]['value'];

    		return $value;
  	}

	/**
	*Format a datetime for human readable goodness.
	*@param string $value
	*@return formatted date
	*/
  	function format_datetime($value){
    		global $message;
		if($value == '0000-00-00'){
			return '00/00/00';
		}
    		if($value){
    			if (($value = strtotime($value)) === -1) {
      				$message->add("error","Error in resource:format_datetime - The string ($str) is bogus");
    			} else {
            			$value = date('m/d/y ',$value);
    			}
    		}

    		return $value;
  	} 


	/**
	*adds a new property and optionally sets its value
	*@param string $name name of the property to add
	*@param string $value optional value of the property
	*/
	function add_prop($name,$value=''){
		if(!$this->prop_exists($name)){
			$this->props[$name] = array('value' => $value,'datatype' => 'dynamic','edit' => '1');
			return 1;
		}
		return 0;
	}
	/**
	*Populates this resource object from an associative array. For example, pass $_POST.
	*Array keys should be propery names. Array values should be the values you want to set the properties to.
	*
	*@param array $array
	*/
	function populate_from_array($array){
		//array should be an associative array containing prop names as keys, values to be set as values
		//for example pass $_POST as $array when the form is submitted
		//first, populate from the id - loading values from database
		
		
	
		if($id=$array['id']){
				//echo "populating"; 
				$this->load($id);
		}
		
		//then - loop through props -setting the value only IF the value is present
		foreach($this->props as $k => $v){
			if(isset($array[$k])){
				$value = $array[$k];

				$this->set_prop($k,$value);
			}
		}
	}


 	/**
        *Automatically populates this resource object from the $_POST array
        */
	function populate_from_form_post(){
		
		if($id=$_POST['id']){
			//echo "populating"; 
			$this->load($id);
		}	
		
		foreach($_POST as $k => $v){
			//echo " $k :: $v<br />";
			if(array_key_exists($k,$this->props) && $k != 'id'){
				if(is_array($v)){
					$list = "";
					foreach($v as $value){
						$list .= "$value,";	
					}	
					$v = preg_replace("/,$/","",$list);
					
				}
				$this->set_prop($k,$v);
			}	
		}
	}
	
	/**
	*Saves this resource.
	*@param  int $suppressmessages 1 or 0 . set to 0 to suppress messages
	*/
	function save($supressmessages=0){
		global $db;
		global $message;
		
		
		if($_SESSION['access_level'] && $_SESSION['access_level'] < 2){
			$message->add('warning','No Write Privilieges to save ' . get_class($this));
			return;
		}
		//if this is a new resource, build insert query
		if($this->new == 1){
		
		
			//if file exists, load the sql from is
			$sqlgen = new sql_generator($this);
			$sql = $sqlgen->get_sql('insert');

			if($sql){
				$res =  $db->query($sql);
				$id = $db->insert_id();
				$this->set_prop('id',$id);
				if(!$supressmessages){
					$message->add("confirmation","New " . $this->friendly_classname() . " " . $id . " saved.");				
				}
				return $res;		
			}else{
				if(!$supressmessages){
					$message->add("error","empty sql");	
				}
			}
		//else build update query				
		}else{
			$sqlgen = new sql_generator($this);
			$sql = $sqlgen->get_sql('update');
			if($sql){
				$sql .= " where " . $this->get_id_string() . "='" . $this->get_prop($this->get_id_string()) . "'";
				$res = $db->query($sql);
				if(!$supressmessages){
					$message->add("confirmation",$this->friendly_classname() ." " . $this->get_prop($this->get_id_string()) . " saved.");
				}
			}else{
				if(!$supressmessages){
					$message->add("error","empty sql");	
				}
			}
		}
		return $res;
	}
	
	/**
	*Deletes this resource.Returns true on sucess, false on failure
	*/
	function delete(){
		global $db;
		global $message;

		$sqlgen = new sql_generator($this);
		$sql = $sqlgen->get_sql('delete');

		if($sql){
			$bool = $db->query($sql);
			if($bool){
				$message->add("confirmation", $this->friendly_classname() . " " . $this->get_prop($this->get_id_string()) . " Deleted.");
			}
			return $bool;
		}else{
				$message->add("error","empty sql");	
		}
	}

	/**
	*Returns number of available resources of this class that match conditions
	*see {@link sql_generator::where_clause()} for how to format the {@link $conditions} array
	*@param array $conditions
	*/
	function count($conditions = array()){
		global $dbcache;
		global $message;

		$sqlgen = new sql_generator($this);
		$sql = $sqlgen->get_sql('count');
		
		if($sql){
			//take of the order by!!!
			if(isset($conditions['order_by'])){
				$conditions['order_by'] = '';
			}
			
			$sql .=  $this->sql_conditions($conditions);
		
			$res = $dbcache->query($sql);
			$row = $res->fetchrow();
			return  $row['count(*)'];
		}else{
			$message->add("error","empty sql");	
		}
	}
	
	/**
	*this is an interface to {@link sql_generator::where_clause()}
	*@param array $conditions
	*@return string where clause
	*/
	function sql_conditions($conditions){
	
		$sqlgen = new sql_generator($this);
		return $sqlgen->where_clause($conditions);
	}	
}
?>
